<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <title>Погода Київ — інтерактивний графік (Open-Meteo, без ключа)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <style>
    :root{
      --olive:#556B2F; --khaki:#C3B091; --sand:#D6CFC7; --dark:#3A3A3A; --accent:#8B0000; --white:#fff;
      --bg1:#2b3321; --bg2:#18200f;
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 75% 20%, #667a42 0%, #4a5c29 40%, #2c311f 100%);color:var(--sand);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:18px}
    .card{width:min(1200px,96vw);height:min(720px,92vh);display:flex;flex-direction:column;border-radius:24px;overflow:hidden;background:linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));border:1px solid rgba(214,207,199,0.25);box-shadow:0 20px 60px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.08)}
    .hdr{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.08)}
    .title{font-weight:700}
    .badge{font-size:12px;padding:6px 10px;border-radius:999px;background:linear-gradient(180deg, rgba(195,176,145,.25), rgba(195,176,145,.15));border:1px solid rgba(195,176,145,.35)}
    .ctrls{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .ctrls label{font-size:12px;opacity:.9}
    .ctrls input,.ctrls select,.ctrls button{
      background:rgba(0,0,0,.25);color:#efeae1;border:1px solid rgba(255,255,255,.18);
      padding:8px 10px;border-radius:12px;outline:none
    }
    .ctrls button{cursor:pointer}
    .chart-area{position:relative;flex:1;padding:12px 14px}
    .legend{position:absolute; right:22px; top:60px; display:flex; gap:12px; z-index:2;
      background:rgba(0,0,0,.15); border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:8px 10px; backdrop-filter: blur(6px)}
    .legend .item{display:flex; align-items:center; gap:8px; font-size:12px}
    .dot{width:10px; height:10px; border-radius:50%;}
    .dot.temp{background:#C3B091}
    .dot.rain{background:#556B2F}
    .foot{padding:8px 14px;border-top:1px solid rgba(255,255,255,.08);font-size:12px;opacity:.85;display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap}
    .err{color:#ffdddd}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="hdr">
      <div class="title">Погода · Київ — інтерактивний графік (дані Open-Meteо)</div>
      <div class="ctrls">
        <label>Період:
          <select id="range">
            <option value="7">7 днів</option>
            <option value="14" selected>14 днів</option>
            <option value="30">30 днів</option>
            <option value="90">90 днів</option>
          </select>
        </label>
        <label>Показники:
          <select id="metrics" multiple size="2" title="Ctrl/Cmd для мультивибору">
            <option value="temperature_2m" selected>Температура (°C)</option>
            <option value="precipitation" selected>Опади (мм)</option>
          </select>
        </label>
        <label>Автооновлення:
          <select id="autorefresh">
            <option value="0" selected>вимкн.</option>
            <option value="15">15 хв</option>
            <option value="30">30 хв</option>
            <option value="60">60 хв</option>
          </select>
        </label>
        <button id="reload">Оновити</button>
      </div>
      <div class="badge">No API key</div>
    </div>

    <div class="chart-area">
      <div class="legend" id="legendBox"></div>
      <canvas id="canvas"></canvas>
    </div>

    <div class="foot">
      <div>Джерело: Open-Meteo (архів + прогноз). Часовий пояс: Europe/Kyiv.</div>
      <div id="status"></div>
    </div>
  </div>
</div>

<script>
/** ====== Налаштування ====== **/
const tz = 'Europe/Kyiv';
const city = 'Kyiv';
let lat = 50.45, lon = 30.523; // (можна змінити на геокодинг за бажання)
const rangeSel = document.getElementById('range');
const metricsSel = document.getElementById('metrics');
const autoSel = document.getElementById('autorefresh');
const statusEl = document.getElementById('status');
const legendBox = document.getElementById('legendBox');

const ctx = document.getElementById('canvas').getContext('2d');
let chart, timerId = null;

/** Градієнти / стилі **/
const gradLine = ctx.createLinearGradient(0,0,0,400);
gradLine.addColorStop(0,'rgba(195,176,145,1)');   // khaki
gradLine.addColorStop(1,'rgba(214,207,199,1)');   // sand
const gradFill = ctx.createLinearGradient(0,0,0,400);
gradFill.addColorStop(0,'rgba(195,176,145,.28)');
gradFill.addColorStop(.6,'rgba(195,176,145,.12)');
gradFill.addColorStop(1,'rgba(195,176,145,0)');
const gradBars = ctx.createLinearGradient(0,0,0,400);
gradBars.addColorStop(0,'rgba(85,107,47,.95)');   // olive
gradBars.addColorStop(1,'rgba(85,107,47,.45)');

/** Плагін тіней для “преміум” вигляду лінії **/
const shadowPlugin = {
  id:'shadow',
  beforeDatasetsDraw(chart){
    const {ctx} = chart;
    chart.data.datasets.forEach((ds,i)=>{
      const meta = chart.getDatasetMeta(i);
      if(!meta.hidden && ds.type==='line'){
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,.35)';
        ctx.shadowBlur = 16;
        ctx.shadowOffsetY = 8;
        meta.dataset.draw(ctx);
        ctx.restore();
      }
    });
  }
};
Chart.register(shadowPlugin);

/** ====== Допоміжні ====== **/
function iso(d){ return d.toISOString().slice(0,10); }
function daysAgo(n){ const d = new Date(); d.setDate(d.getDate()-n); return d; }
function selMetrics(){
  return Array.from(metricsSel.selectedOptions).map(o=>o.value);
}
function setStatus(msg, isErr=false){
  statusEl.textContent = msg || '';
  statusEl.className = isErr ? 'err' : '';
}

/** ====== Фетчери Open-Meteo (без ключа) ====== **/
async function fetchArchive(startDate, endDate, metrics){
  const url = new URL('https://archive-api.open-meteo.com/v1/archive');
  url.search = new URLSearchParams({
    latitude: lat, longitude: lon,
    hourly: metrics.join(','),
    start_date: startDate, end_date: endDate,
    timezone: tz
  });
  const res = await fetch(url);
  if(!res.ok) throw new Error('Помилка archive API');
  return res.json();
}
async function fetchForecast(metrics){
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude: lat, longitude: lon,
    hourly: metrics.join(','),
    timezone: tz
  });
  const res = await fetch(url);
  if(!res.ok) throw new Error('Помилка forecast API');
  return res.json();
}

/** Комбінує архів + прогноз (якщо кінець >= сьогодні) **/
async function getData(days, metrics){
  const end = new Date();
  const start = daysAgo(days-1);
  const startStr = iso(start), endStr = iso(end);
  const arch = await fetchArchive(startStr, endStr, metrics);

  // Підготовка контейнерів
  const times = arch.hourly.time.slice(); // копія
  const series = {};
  metrics.forEach(m => { series[m] = arch.hourly[m]?.slice() ?? []; });

  // Додаємо прогнозні години, якщо доступні й нові
  const forecast = await fetchForecast(metrics);
  const tFc = forecast.hourly.time;
  metrics.forEach(m=>{
    const fcArr = forecast.hourly[m];
    if(!fcArr) return;
    const last = times[times.length-1];
    for(let i=0;i<tFc.length;i++){
      if(tFc[i] > last){
        if(i===0) times.push(tFc[i]); else if(times[times.length-1]!==tFc[i]) times.push(tFc[i]);
        series[m].push(fcArr[i]);
      }
    }
  });

  // Узгодження довжин (на випадок відсутнього показника)
  const n = times.length;
  metrics.forEach(m=>{
    const arr = series[m] || [];
    if(arr.length < n){ // доповнюємо null’ами
      while(arr.length < n) arr.push(null);
      series[m] = arr;
    }
  });

  return { times, series, startStr, endStr };
}

/** Легенда під вибрані метрики **/
function renderLegend(metrics){
  const html = metrics.map(m=>{
    const name = (m==='temperature_2m')?'Температура, °C':'Опади, мм';
    const cls = (m==='temperature_2m')?'temp':'rain';
    return `<div class="item"><span class="dot ${cls}"></span>${name}</div>`;
  }).join('');
  legendBox.innerHTML = html;
}

/** Побудова чарта **/
function renderChart(times, series, metrics){
  // Підпис по осі X (година → “ММ.ДД HH:00” з ужаттям)
  const labels = times.map(t => t.replace('T',' ').slice(5,16));

  // Датасети в залежності від вибору
  const datasets = [];
  if(metrics.includes('temperature_2m')){
    datasets.push({
      type:'line', label:'Температура, °C',
      data: series['temperature_2m'],
      tension:.35, borderColor:gradLine, backgroundColor:gradFill, fill:true,
      pointRadius:2, pointHoverRadius:5, yAxisID:'y', borderWidth:3
    });
  }
  if(metrics.includes('precipitation')){
    datasets.push({
      type:'bar', label:'Опади, мм',
      data: series['precipitation'],
      backgroundColor:gradBars, borderRadius:8, yAxisID:'y1',
      barThickness:'flex', maxBarThickness:22
    });
  }

  const data = { labels, datasets };

  const options = {
    responsive:true, maintainAspectRatio:false,
    layout:{padding:{left:10,right:10,top:10,bottom:10}},
    scales:{
      x:{ grid:{color:'rgba(255,255,255,.06)', drawTicks:false}, ticks:{color:'#EDE8E1', maxRotation:0} },
      y:{ position:'left', grid:{color:'rgba(255,255,255,.06)'}, ticks:{color:'#EDE8E1', callback:v=>v+'°'}, title:{display:metrics.includes('temperature_2m'), text:'°C', color:'#EDE8E1', font:{weight:'600'}}, suggestedMin:null },
      y1:{ position:'right', grid:{drawOnChartArea:false}, ticks:{color:'#EDE8E1'}, title:{display:metrics.includes('precipitation'), text:'мм', color:'#EDE8E1', font:{weight:'600'}} }
    },
    plugins:{
      legend:{display:false},
      tooltip:{
        backgroundColor:'rgba(0,0,0,.75)', borderColor:'rgba(255,255,255,.12)', borderWidth:1, padding:12,
        displayColors:true, mode:'index', intersect:false,
        callbacks:{
          label:(ctx)=>{
            const v = ctx.parsed.y;
            if(ctx.dataset.type==='bar') return ` Опади: ${v??'—'} мм`;
            return ` Темп.: ${v??'—'} °C`;
          },
          title:(items)=>`Час: ${times[items[0].dataIndex].replace('T',' ')}`
        }
      }
    },
    interaction:{mode:'index', intersect:false},
    animation:{duration:900, easing:'easeOutQuart'}
  };

  if(chart) chart.destroy();
  chart = new Chart(ctx, {data, options});
}

/** Головний цикл завантаження/рендеру **/
async function refresh(){
  const days = parseInt(rangeSel.value,10);
  const metrics = selMetrics();
  if(metrics.length===0){
    setStatus('Оберіть принаймні один показник', true);
    return;
  }
  setStatus('Завантаження…');
  try{
    const {times, series, startStr, endStr} = await getData(days, metrics);
    renderLegend(metrics);
    renderChart(times, series, metrics);
    setStatus(`Період: ${startStr} → ${endStr} • Точок: ${times.length}`);
  }catch(e){
    console.error(e);
    setStatus('Помилка завантаження даних (Open-Meteo).', true);
  }
}

/** Події керування **/
document.getElementById('reload').addEventListener('click', refresh);
rangeSel.addEventListener('change', refresh);
metricsSel.addEventListener('change', refresh);
autoSel.addEventListener('change', ()=>{
  if(timerId) { clearInterval(timerId); timerId=null; }
  const m = parseInt(autoSel.value,10);
  if(m>0){ timerId = setInterval(refresh, m*60*1000); }
});

/** Перший рендер **/
refresh();
</script>
</body>
</html>
